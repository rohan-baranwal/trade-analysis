/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/path/path.js
var require_path = __commonJS({
  "node_modules/path/path.js"(exports2, module2) {
    globalThis.process ??= {
      platform: "mobile",
      cwd: () => "/",
      env: {}
    };
    var isWindows = process.platform === "win32";
    var util = require("util");
    function normalizeArray(parts, allowAboveRoot) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (!p || p === ".")
          continue;
        if (p === "..") {
          if (res.length && res[res.length - 1] !== "..") {
            res.pop();
          } else if (allowAboveRoot) {
            res.push("..");
          }
        } else {
          res.push(p);
        }
      }
      return res;
    }
    function trimArray(arr) {
      var lastIndex = arr.length - 1;
      var start = 0;
      for (; start <= lastIndex; start++) {
        if (arr[start])
          break;
      }
      var end = lastIndex;
      for (; end >= 0; end--) {
        if (arr[end])
          break;
      }
      if (start === 0 && end === lastIndex)
        return arr;
      if (start > end)
        return [];
      return arr.slice(start, end + 1);
    }
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
    var win32 = {};
    function win32SplitPath(filename) {
      var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
      var result2 = splitTailRe.exec(tail), dir = result2[1], basename4 = result2[2], ext = result2[3];
      return [device, dir, basename4, ext];
    }
    function win32StatPath(path) {
      var result = splitDeviceRe.exec(path), device = result[1] || "", isUnc = !!device && device[1] !== ":";
      return {
        device,
        isUnc,
        isAbsolute: isUnc || !!result[2],
        // UNC paths are always absolute
        tail: result[3]
      };
    }
    function normalizeUNCRoot(device) {
      return "\\\\" + device.replace(/^[\\\/]+/, "").replace(/[\\\/]+/g, "\\");
    }
    win32.resolve = function() {
      var resolvedDevice = "", resolvedTail = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1; i--) {
        var path;
        if (i >= 0) {
          path = arguments[i];
        } else if (!resolvedDevice) {
          path = process.cwd();
        } else {
          path = process.env["=" + resolvedDevice];
          if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + "\\") {
            path = resolvedDevice + "\\";
          }
        }
        if (!util.isString(path)) {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          continue;
        }
        var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail;
        if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
          continue;
        }
        if (!resolvedDevice) {
          resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
          resolvedTail = tail + "\\" + resolvedTail;
          resolvedAbsolute = isAbsolute;
        }
        if (resolvedDevice && resolvedAbsolute) {
          break;
        }
      }
      if (isUnc) {
        resolvedDevice = normalizeUNCRoot(resolvedDevice);
      }
      resolvedTail = normalizeArray(
        resolvedTail.split(/[\\\/]+/),
        !resolvedAbsolute
      ).join("\\");
      return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    };
    win32.normalize = function(path) {
      var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail, trailingSlash = /[\\\/]$/.test(tail);
      tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join("\\");
      if (!tail && !isAbsolute) {
        tail = ".";
      }
      if (tail && trailingSlash) {
        tail += "\\";
      }
      if (isUnc) {
        device = normalizeUNCRoot(device);
      }
      return device + (isAbsolute ? "\\" : "") + tail;
    };
    win32.isAbsolute = function(path) {
      return win32StatPath(path).isAbsolute;
    };
    win32.join = function() {
      var paths = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!util.isString(arg)) {
          throw new TypeError("Arguments to path.join must be strings");
        }
        if (arg) {
          paths.push(arg);
        }
      }
      var joined = paths.join("\\");
      if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
        joined = joined.replace(/^[\\\/]{2,}/, "\\");
      }
      return win32.normalize(joined);
    };
    win32.relative = function(from, to) {
      from = win32.resolve(from);
      to = win32.resolve(to);
      var lowerFrom = from.toLowerCase();
      var lowerTo = to.toLowerCase();
      var toParts = trimArray(to.split("\\"));
      var lowerFromParts = trimArray(lowerFrom.split("\\"));
      var lowerToParts = trimArray(lowerTo.split("\\"));
      var length = Math.min(lowerFromParts.length, lowerToParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (lowerFromParts[i] !== lowerToParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      if (samePartsLength == 0) {
        return to;
      }
      var outputParts = [];
      for (var i = samePartsLength; i < lowerFromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("\\");
    };
    win32._makeLong = function(path) {
      if (!util.isString(path))
        return path;
      if (!path) {
        return "";
      }
      var resolvedPath = win32.resolve(path);
      if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
        return "\\\\?\\" + resolvedPath;
      } else if (/^\\\\[^?.]/.test(resolvedPath)) {
        return "\\\\?\\UNC\\" + resolvedPath.substring(2);
      }
      return path;
    };
    win32.dirname = function(path) {
      var result = win32SplitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    win32.basename = function(path, ext) {
      var f = win32SplitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    win32.extname = function(path) {
      return win32SplitPath(path)[3];
    };
    win32.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
          "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
      var root = pathObject.root || "";
      if (!util.isString(root)) {
        throw new TypeError(
          "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
        );
      }
      var dir = pathObject.dir;
      var base = pathObject.base || "";
      if (!dir) {
        return base;
      }
      if (dir[dir.length - 1] === win32.sep) {
        return dir + base;
      }
      return dir + win32.sep + base;
    };
    win32.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    win32.sep = "\\";
    win32.delimiter = ";";
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var posix7 = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix7.resolve = function() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : process.cwd();
        if (!util.isString(path)) {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path[0] === "/";
      }
      resolvedPath = normalizeArray(
        resolvedPath.split("/"),
        !resolvedAbsolute
      ).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    };
    posix7.normalize = function(path) {
      var isAbsolute = posix7.isAbsolute(path), trailingSlash = path && path[path.length - 1] === "/";
      path = normalizeArray(path.split("/"), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    };
    posix7.isAbsolute = function(path) {
      return path.charAt(0) === "/";
    };
    posix7.join = function() {
      var path = "";
      for (var i = 0; i < arguments.length; i++) {
        var segment = arguments[i];
        if (!util.isString(segment)) {
          throw new TypeError("Arguments to path.join must be strings");
        }
        if (segment) {
          if (!path) {
            path += segment;
          } else {
            path += "/" + segment;
          }
        }
      }
      return posix7.normalize(path);
    };
    posix7.relative = function(from, to) {
      from = posix7.resolve(from).substr(1);
      to = posix7.resolve(to).substr(1);
      var fromParts = trimArray(from.split("/"));
      var toParts = trimArray(to.split("/"));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join("/");
    };
    posix7._makeLong = function(path) {
      return path;
    };
    posix7.dirname = function(path) {
      var result = posixSplitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return ".";
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    posix7.basename = function(path, ext) {
      var f = posixSplitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    posix7.extname = function(path) {
      return posixSplitPath(path)[3];
    };
    posix7.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
          "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
      var root = pathObject.root || "";
      if (!util.isString(root)) {
        throw new TypeError(
          "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
        );
      }
      var dir = pathObject.dir ? pathObject.dir + posix7.sep : "";
      var base = pathObject.base || "";
      return dir + base;
    };
    posix7.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      allParts[1] = allParts[1] || "";
      allParts[2] = allParts[2] || "";
      allParts[3] = allParts[3] || "";
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    posix7.sep = "/";
    posix7.delimiter = ":";
    if (isWindows)
      module2.exports = win32;
    else
      module2.exports = posix7;
    module2.exports.posix = posix7;
    module2.exports.win32 = win32;
  }
});

// node_modules/obsidian-typings/dist/implementations.cjs
var require_implementations = __commonJS({
  "node_modules/obsidian-typings/dist/implementations.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var implementations_exports = {};
    __export2(implementations_exports, {
      CustomArrayDictImpl: () => CustomArrayDictImpl,
      InternalPluginName: () => InternalPluginName,
      createTFileInstance: () => createTFileInstance3,
      createTFolderInstance: () => createTFolderInstance,
      parentFolderPath: () => parentFolderPath
    });
    module2.exports = __toCommonJS2(implementations_exports);
    function parentFolderPath(path) {
      return path.replace(/\/?[^\/]*$/, "") || "/";
    }
    var import_obsidian9 = require("obsidian");
    function createTFolderInstance(vault, path) {
      let folder = vault.getFolderByPath(path);
      if (folder) {
        return folder;
      }
      folder = new import_obsidian9.TFolder(vault, path);
      folder.parent = createTFolderInstance(vault, parentFolderPath(path));
      folder.deleted = true;
      return folder;
    }
    var import_obsidian22 = require("obsidian");
    function createTFileInstance3(vault, path) {
      let file = vault.getFileByPath(path);
      if (file) {
        return file;
      }
      file = new import_obsidian22.TFile(vault, path);
      file.parent = createTFolderInstance(vault, parentFolderPath(path));
      file.deleted = true;
      return file;
    }
    var CustomArrayDictImpl = class {
      data = {};
      add(key, value) {
        if (!this.data.hasOwnProperty(key)) {
          this.data[key] = [];
        }
        const values = this.data[key];
        if (!values.includes(value)) {
          values.push(value);
        }
      }
      remove(key, value) {
        const values = this.data[key];
        if (!values) {
          return;
        }
        values.remove(value);
        if (values.length === 0) {
          delete this.data[key];
        }
      }
      removeKey(key) {
        delete this.data[key];
      }
      get(key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
      }
      keys() {
        return Object.keys(this.data);
      }
      clear(key) {
        delete this.data[key];
      }
      clearAll() {
        this.data = {};
      }
      contains(key, value) {
        const values = this.data[key];
        return values && values.contains(value) || false;
      }
      count() {
        let ans = 0;
        for (const key in this.data) {
          if (this.data.hasOwnProperty(key)) {
            ans += this.data[key].length;
          }
        }
        return ans;
      }
    };
    var InternalPluginName = {
      AudioRecorder: "audio-recorder",
      Backlink: "backlink",
      Bookmarks: "bookmarks",
      Canvas: "canvas",
      CommandPalette: "command-palette",
      DailyNotes: "daily-notes",
      EditorStatus: "editor-status",
      FileExplorer: "file-explorer",
      FileRecovery: "file-recovery",
      GlobalSearch: "global-search",
      Graph: "graph",
      MarkdownImporter: "markdown-importer",
      NoteComposer: "note-composer",
      OutgoingLink: "outgoing-link",
      Outline: "outline",
      PagePreview: "page-preview",
      Properties: "properties",
      Publish: "publish",
      RandomNote: "random-note",
      SlashCommand: "slash-command",
      Slides: "slides",
      Starred: "starred",
      Switcher: "switcher",
      Sync: "sync",
      TagPane: "tag-pane",
      Templates: "templates",
      WordCount: "word-count",
      Workspaces: "workspaces",
      ZkPrefixer: "zk-prefixer"
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ConsistentAttachmentsAndLinksPlugin
});
module.exports = __toCommonJS(main_exports);

// src/ConsistentAttachmentsAndLinksPlugin.ts
var import_obsidian8 = require("obsidian");

// src/links-handler.ts
var import_obsidian4 = require("obsidian");
var import_path2 = __toESM(require_path(), 1);

// src/Error.ts
var import_obsidian = require("obsidian");
function showError(error) {
  console.error(error);
  new import_obsidian.Notice("An unhandled error occurred. Please check the console for more information.");
}

// src/Async.ts
async function retryWithTimeout(asyncFn, retryOptions = {}) {
  const DEFAULT_RETRY_OPTIONS = {
    timeoutInMilliseconds: 5e3,
    retryDelayInMilliseconds: 100
  };
  const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
  await runWithTimeout(overriddenOptions.timeoutInMilliseconds, async () => {
    let attempt = 0;
    while (true) {
      attempt++;
      if (await asyncFn()) {
        if (attempt > 1) {
          console.debug(`Retry completed successfully after ${attempt} attempts`);
        }
        return;
      }
      console.debug(`Retry attempt ${attempt} completed unsuccessfully. Trying again in ${overriddenOptions.retryDelayInMilliseconds} milliseconds`);
      console.debug(asyncFn);
      await sleep(overriddenOptions.retryDelayInMilliseconds);
    }
  });
}
async function runWithTimeout(timeoutInMilliseconds, asyncFn) {
  return await Promise.race([asyncFn(), timeout(timeoutInMilliseconds)]);
}
async function timeout(timeoutInMilliseconds) {
  await sleep(timeoutInMilliseconds);
  throw new Error(`Timed out in ${timeoutInMilliseconds} milliseconds`);
}
function convertToSync(promise) {
  promise.catch(showError);
}
function convertAsyncToSync(asyncFunc) {
  return (...args) => convertToSync(asyncFunc(...args));
}

// src/MetadataCache.ts
async function getCacheSafe(app, fileOrPath, retryOptions = {}) {
  const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
  const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
  let cache = null;
  await retryWithTimeout(async () => {
    const file = typeof fileOrPath === "string" ? app.vault.getFileByPath(fileOrPath) : fileOrPath;
    if (!file) {
      cache = null;
      return true;
    }
    await saveNote(app, file);
    const fileInfo = app.metadataCache.getFileInfo(file.path);
    const stat = await app.vault.adapter.stat(file.path);
    if (!fileInfo) {
      console.debug(`File cache info for ${file.path} is missing`);
      return false;
    } else if (!stat) {
      console.debug(`File stat for ${file.path} is missing`);
      return false;
    } else if (fileInfo.mtime < stat.mtime) {
      console.debug(`File cache info for ${file.path} is from ${new Date(fileInfo.mtime).toString()} which is older than the file modification timestamp ${new Date(stat.mtime).toString()}`);
      return false;
    } else {
      cache = app.metadataCache.getFileCache(file);
      if (!cache) {
        console.debug(`File cache for ${file.path} is missing`);
        return false;
      } else {
        return true;
      }
    }
  }, overriddenOptions);
  return cache;
}
function getAllLinks(cache) {
  let links = [];
  if (cache.links) {
    links.push(...cache.links);
  }
  if (cache.embeds) {
    links.push(...cache.embeds);
  }
  links.sort((a, b) => a.position.start.offset - b.position.start.offset);
  links = links.filter((link, index) => {
    if (index === 0) {
      return true;
    }
    return link.position.start.offset !== links[index - 1].position.start.offset;
  });
  return links;
}
async function getBacklinksForFileSafe(app, file, retryOptions = {}) {
  const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
  const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
  let backlinks = null;
  await retryWithTimeout(async () => {
    backlinks = app.metadataCache.getBacklinksForFile(file);
    for (const notePath of backlinks.keys()) {
      const note = app.vault.getFileByPath(notePath);
      if (!note) {
        return false;
      }
      await saveNote(app, note);
      const content = await app.vault.read(note);
      const links = backlinks.get(notePath);
      for (const link of links) {
        const actualLink = content.slice(link.position.start.offset, link.position.end.offset);
        if (actualLink !== link.original) {
          return false;
        }
      }
    }
    return true;
  }, overriddenOptions);
  return backlinks;
}
async function saveNote(app, note) {
  if (note.extension.toLowerCase() !== "md") {
    return;
  }
  for (const leaf of app.workspace.getLeavesOfType("markdown")) {
    const view = leaf.view;
    if (view.file?.path === note.path) {
      await view.save();
    }
  }
}

// src/Vault.ts
var import_obsidian2 = require("obsidian");

// src/Object.ts
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== "object" || typeof b !== "object" || a === null || b === null || a === void 0 || b === void 0) {
    return false;
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const aRecord = a;
  const bRecord = b;
  for (const key of keysA) {
    if (!keysB.includes(key) || !deepEqual(aRecord[key], bRecord[key])) {
      return false;
    }
  }
  return true;
}
function toJson(value) {
  return JSON.stringify(value, null, 2);
}

// src/Vault.ts
function getMarkdownFilesSorted(app) {
  return app.vault.getMarkdownFiles().sort((a, b) => a.path.localeCompare(b.path));
}
async function processWithRetry(app, file, processFn, retryOptions = {}) {
  const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
  const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
  await retryWithTimeout(async () => {
    const oldContent = await app.vault.adapter.read(file.path);
    const newContent = await processFn(oldContent);
    if (newContent === null) {
      return false;
    }
    let success = true;
    await app.vault.process(file, (content) => {
      if (content !== oldContent) {
        console.warn(`Content of ${file.path} has changed since it was read. Retrying...`);
        success = false;
        return content;
      }
      return newContent;
    });
    return success;
  }, overriddenOptions);
}
async function applyFileChanges(app, file, changesFn, retryOptions = {}) {
  const DEFAULT_RETRY_OPTIONS = { timeoutInMilliseconds: 6e4 };
  const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
  await processWithRetry(app, file, async (content) => {
    let changes = await changesFn();
    for (const change of changes) {
      const actualContent = content.slice(change.startIndex, change.endIndex);
      if (actualContent !== change.oldContent) {
        console.warn(`Content mismatch at ${change.startIndex}-${change.endIndex} in ${file.path}:
Expected: ${change.oldContent}
Actual: ${actualContent}`);
        return null;
      }
    }
    changes.sort((a, b) => a.startIndex - b.startIndex);
    changes = changes.filter((change, index) => {
      if (index === 0) {
        return true;
      }
      return !deepEqual(change, changes[index - 1]);
    });
    for (let i = 1; i < changes.length; i++) {
      const change = changes[i];
      const previousChange = changes[i - 1];
      if (previousChange.endIndex > change.startIndex) {
        console.warn(`Overlapping changes:
${toJson(previousChange)}
${toJson(change)}`);
        return null;
      }
    }
    let newContent = "";
    let lastIndex = 0;
    for (const change of changes) {
      newContent += content.slice(lastIndex, change.startIndex);
      newContent += change.newContent;
      lastIndex = change.endIndex;
    }
    newContent += content.slice(lastIndex);
    return newContent;
  }, overriddenOptions);
}
function isNote(file) {
  if (!(file instanceof import_obsidian2.TFile)) {
    return false;
  }
  const extension = file.extension.toLowerCase();
  return extension === "md" || extension === "canvas";
}
async function removeFolderSafe(app, folderPath, removedNotePath) {
  const folder = app.vault.getFolderByPath(folderPath);
  if (!folder) {
    return false;
  }
  let canRemove = true;
  for (const child of folder.children) {
    if (child instanceof import_obsidian2.TFile) {
      const backlinks = await getBacklinksForFileSafe(app, child);
      if (removedNotePath) {
        backlinks.removeKey(removedNotePath);
      }
      if (backlinks.count() !== 0) {
        new import_obsidian2.Notice(`Attachment ${child.path} is still used by other notes. It will not be deleted.`);
        canRemove = false;
      } else {
        try {
          await app.vault.delete(child);
        } catch (e) {
          if (await app.vault.adapter.exists(child.path)) {
            console.error(`Failed to delete ${child.path}`, e);
            canRemove = false;
          }
        }
      }
    } else if (child instanceof import_obsidian2.TFolder) {
      canRemove &&= await removeFolderSafe(app, child.path, removedNotePath);
    }
  }
  if (canRemove) {
    try {
      await app.vault.delete(folder, true);
    } catch (e) {
      if (await app.vault.adapter.exists(folder.path)) {
        console.error(`Failed to delete ${folder.path}`, e);
        canRemove = false;
      }
    }
  }
  return canRemove;
}
async function createFolderSafe(app, path) {
  if (await app.vault.adapter.exists(path)) {
    return;
  }
  try {
    await app.vault.adapter.mkdir(path);
  } catch (e) {
    if (!await app.vault.adapter.exists(path)) {
      throw e;
    }
  }
}
async function safeList(app, path) {
  const EMPTY = { files: [], folders: [] };
  if (!await app.vault.adapter.exists(path)) {
    return EMPTY;
  }
  try {
    return await app.vault.adapter.list(path);
  } catch (e) {
    if (await app.vault.adapter.exists(path)) {
      throw e;
    }
    return EMPTY;
  }
}
async function removeEmptyFolderHierarchy(app, folder) {
  while (folder) {
    if (folder.children.length > 0) {
      return;
    }
    await removeFolderSafe(app, folder.path);
    folder = folder.parent;
  }
}

// src/Link.ts
var import_obsidian3 = require("obsidian");
var import_path = __toESM(require_path(), 1);

// src/GenerateMarkdownLink.ts
function generateMarkdownLink({
  app,
  file,
  sourcePath,
  subpath,
  alias,
  isEmbed,
  isWikilink,
  isRelative
}) {
  const useMarkdownLinks = app.vault.getConfig("useMarkdownLinks");
  const newLinkFormat = app.vault.getConfig("newLinkFormat");
  if (isWikilink !== void 0) {
    app.vault.setConfig("useMarkdownLinks", !isWikilink);
  }
  if (isRelative === true) {
    app.vault.setConfig("newLinkFormat", "relative");
  }
  let link = app.fileManager.generateMarkdownLink(file, sourcePath, subpath, alias);
  app.vault.setConfig("useMarkdownLinks", useMarkdownLinks);
  app.vault.setConfig("newLinkFormat", newLinkFormat);
  const isLinkEmbed = link.startsWith("!");
  if (isEmbed !== void 0 && isEmbed !== isLinkEmbed) {
    if (isEmbed) {
      link = "!" + link;
    } else {
      link = link.slice(1);
      link = link.replace("[]", `[${alias || file.basename}]`);
    }
  }
  return link;
}

// src/Link.ts
var import_implementations = __toESM(require_implementations(), 1);
var {
  basename,
  extname
} = import_path.posix;
function splitSubpath(link) {
  const SUBPATH_SEPARATOR = "#";
  const [linkPath = "", subpath] = link.split(SUBPATH_SEPARATOR);
  return {
    linkPath,
    subpath: subpath ? SUBPATH_SEPARATOR + subpath : void 0
  };
}
async function updateLinksInFile({
  app,
  file,
  oldPath,
  renameMap,
  forceMarkdownLinks,
  embedOnlyLinks
}) {
  await applyFileChanges(app, file, async () => {
    const cache = await getCacheSafe(app, file);
    if (!cache) {
      return [];
    }
    let links = [];
    switch (embedOnlyLinks) {
      case true:
        links = cache.embeds ?? [];
        break;
      case false:
        links = cache.links ?? [];
        break;
      case void 0:
        links = getAllLinks(cache);
        break;
    }
    return links.map((link) => ({
      startIndex: link.position.start.offset,
      endIndex: link.position.end.offset,
      oldContent: link.original,
      newContent: convertLink(app, link, file, oldPath, renameMap, forceMarkdownLinks)
    }));
  });
}
function convertLink(app, link, source, oldPath, renameMap, forceMarkdownLinks) {
  oldPath ??= source.path;
  return updateLink({
    app,
    link,
    file: extractLinkFile(app, link, oldPath),
    oldPath,
    source,
    renameMap,
    forceMarkdownLinks
  });
}
function extractLinkFile(app, link, oldPath) {
  const { linkPath } = splitSubpath(link.link);
  return app.metadataCache.getFirstLinkpathDest(linkPath, oldPath);
}
function updateLink({
  app,
  link,
  file,
  oldPath,
  source,
  renameMap,
  forceMarkdownLinks
}) {
  if (!file) {
    return link.original;
  }
  const isEmbed = link.original.startsWith("!");
  const isWikilink = link.original.includes("[[") && forceMarkdownLinks !== true;
  const { subpath } = splitSubpath(link.link);
  const newPath = renameMap.get(file.path);
  const alias = getAlias({
    app,
    displayText: link.displayText,
    file,
    otherPaths: [oldPath, newPath],
    sourcePath: source.path
  });
  if (newPath) {
    file = (0, import_implementations.createTFileInstance)(app.vault, newPath);
  }
  const newLink = generateMarkdownLink({
    app,
    file,
    sourcePath: source.path,
    subpath,
    alias,
    isEmbed,
    isWikilink
  });
  return newLink;
}
function getAlias({
  app,
  displayText,
  file,
  otherPaths,
  sourcePath
}) {
  if (!displayText) {
    return void 0;
  }
  const cleanDisplayText = (0, import_obsidian3.normalizePath)(displayText.split(" > ")[0]).replace(/\.\//g, "");
  for (const path of [file.path, ...otherPaths]) {
    if (!path) {
      continue;
    }
    const extension = extname(path);
    const fileNameWithExtension = basename(path);
    const fileNameWithoutExtension = basename(path, extension);
    if (cleanDisplayText === path || cleanDisplayText === fileNameWithExtension || cleanDisplayText === fileNameWithoutExtension) {
      return void 0;
    }
  }
  for (const omitMdExtension of [true, false]) {
    const linkText = app.metadataCache.fileToLinktext(file, sourcePath, omitMdExtension);
    if (cleanDisplayText === linkText) {
      return void 0;
    }
  }
  return displayText;
}

// src/links-handler.ts
var {
  dirname,
  join
} = import_path2.posix;
var ConsistencyCheckResult = class extends Map {
  constructor(title) {
    super();
    this.title = title;
  }
  add(notePath, link) {
    if (!this.has(notePath)) {
      this.set(notePath, []);
    }
    this.get(notePath).push(link);
  }
  toString(app, reportPath) {
    if (this.size > 0) {
      let str = `# ${this.title} (${this.size} files)
`;
      for (const notePath of this.keys()) {
        const linkStr = app.fileManager.generateMarkdownLink(app.vault.getFileByPath(notePath), reportPath);
        str += `${linkStr}:
`;
        for (const link of this.get(notePath)) {
          str += `- (line ${link.position.start.line + 1}): \`${link.link}\`
`;
        }
        str += "\n\n";
      }
      return str;
    } else {
      return `# ${this.title}
No problems found

`;
    }
  }
};
var LinksHandler = class {
  constructor(app, consoleLogPrefix = "", ignoreFolders = [], ignoreFilesRegex = []) {
    this.app = app;
    this.consoleLogPrefix = consoleLogPrefix;
    this.ignoreFolders = ignoreFolders;
    this.ignoreFilesRegex = ignoreFilesRegex;
  }
  isPathIgnored(path) {
    if (path.startsWith("./")) {
      path = path.substring(2);
    }
    for (const folder of this.ignoreFolders) {
      if (path.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this.ignoreFilesRegex) {
      if (fileRegex.test(path)) {
        return true;
      }
    }
    return false;
  }
  getFileByLink(link, owningNotePath, allowInvalidLink = true) {
    ({ linkPath: link } = splitSubpath(link));
    if (allowInvalidLink) {
      return this.app.metadataCache.getFirstLinkpathDest(link, owningNotePath);
    }
    const fullPath = this.getFullPathForLink(link, owningNotePath);
    return this.app.vault.getFileByPath(fullPath);
  }
  getFullPathForLink(link, owningNotePath) {
    ({ linkPath: link } = splitSubpath(link));
    const parentFolder = dirname(owningNotePath);
    const fullPath = join(parentFolder, link);
    return fullPath;
  }
  async isValidLink(link, notePath) {
    const { linkPath, subpath } = splitSubpath(link.link);
    let fullLinkPath;
    if (!linkPath) {
      fullLinkPath = notePath;
    } else if (linkPath.startsWith("/")) {
      fullLinkPath = (0, import_obsidian4.normalizePath)(linkPath);
    } else {
      fullLinkPath = join(dirname(notePath), linkPath);
    }
    const file = this.app.vault.getFileByPath(fullLinkPath);
    if (!file) {
      return false;
    }
    if (!subpath) {
      return true;
    }
    const ext = file.extension.toLocaleLowerCase();
    if (ext === "pdf") {
      return subpath.startsWith("#page=");
    }
    if (ext !== "md") {
      return false;
    }
    const cache = await getCacheSafe(this.app, file);
    if (!cache) {
      return false;
    }
    if (subpath.startsWith("#^")) {
      return Object.keys(cache.blocks ?? {}).includes(subpath.slice(2));
    } else {
      return (cache.headings ?? []).map((h) => h.heading.replaceAll("#", " ")).includes(subpath.slice(1));
    }
  }
  async updateChangedPathsInNote(notePath, changedLinks, changeLinksAlt = false) {
    if (this.isPathIgnored(notePath)) {
      return;
    }
    const note = this.app.vault.getFileByPath(notePath);
    if (!note) {
      console.warn(this.consoleLogPrefix + "can't update links in note, file not found: " + notePath);
      return;
    }
    const pathChangeMap = /* @__PURE__ */ new Map();
    for (const change of changedLinks) {
      pathChangeMap.set(change.oldPath, change.newPath);
    }
    await this.updateLinks(note, note.path, pathChangeMap, changeLinksAlt);
  }
  convertLink({
    note,
    link,
    oldNotePath,
    pathChangeMap,
    changeLinksAlt,
    isEmbed,
    isWikilink,
    isRelative
  }) {
    const { linkPath, subpath } = splitSubpath(link.link);
    this.app.metadataCache.getFirstLinkpathDest(linkPath, oldNotePath);
    const oldLinkPath = this.app.metadataCache.getFirstLinkpathDest(linkPath, oldNotePath)?.path ?? join(dirname(oldNotePath), linkPath);
    const newLinkPath = pathChangeMap ? pathChangeMap.get(oldLinkPath) : this.app.metadataCache.getFirstLinkpathDest(linkPath, note.path)?.path ?? join(dirname(note.path), linkPath);
    if (!newLinkPath) {
      return link.original;
    }
    const newLinkedNote = this.app.vault.getFileByPath(oldLinkPath) ?? this.app.vault.getFileByPath(newLinkPath);
    if (!newLinkedNote) {
      return link.original;
    }
    return generateMarkdownLink({
      app: this.app,
      file: newLinkedNote,
      sourcePath: note.path,
      subpath,
      alias: changeLinksAlt === false ? link.displayText : void 0,
      isEmbed,
      isWikilink,
      isRelative
    });
  }
  async getCachedNotesThatHaveLinkToFile(filePath) {
    const file = this.app.vault.getFileByPath(filePath);
    if (!file) {
      return [];
    }
    const backlinks = await getBacklinksForFileSafe(this.app, file);
    return backlinks.keys();
  }
  async convertAllNoteEmbedsPathsToRelative(notePath) {
    return this.convertAllNoteRefPathsToRelative(notePath, true);
  }
  async convertAllNoteRefPathsToRelative(notePath, isEmbed) {
    if (this.isPathIgnored(notePath)) {
      return [];
    }
    const note = this.app.vault.getFileByPath(notePath);
    if (!note) {
      return [];
    }
    const changedRefs = [];
    await applyFileChanges(this.app, note, async () => {
      const cache = await getCacheSafe(this.app, note);
      if (!cache) {
        return [];
      }
      const refs = (isEmbed ? cache.embeds : cache.links) ?? [];
      const changes = [];
      for (const ref of refs) {
        const change = {
          startIndex: ref.position.start.offset,
          endIndex: ref.position.end.offset,
          oldContent: ref.original,
          newContent: this.convertLink({
            note,
            link: ref,
            oldNotePath: notePath,
            isWikilink: ref.original.includes("[["),
            isRelative: true
          })
        };
        changes.push(change);
        changedRefs.push({ old: ref, newLink: change.newContent });
      }
      return changes;
    });
    return changedRefs;
  }
  async convertAllNoteLinksPathsToRelative(notePath) {
    return this.convertAllNoteRefPathsToRelative(notePath, false);
  }
  async replaceAllNoteWikilinksWithMarkdownLinks(notePath, embedOnlyLinks) {
    if (this.isPathIgnored(notePath)) {
      return 0;
    }
    const noteFile = this.app.vault.getFileByPath(notePath);
    if (!noteFile) {
      console.warn(this.consoleLogPrefix + "can't update wikilinks in note, file not found: " + notePath);
      return 0;
    }
    const cache = await getCacheSafe(this.app, noteFile);
    if (!cache) {
      return 0;
    }
    const links = (embedOnlyLinks ? cache.embeds : cache.links) ?? [];
    const result = links.filter((link) => link.original.includes("[[")).length;
    await updateLinksInFile({
      app: this.app,
      file: noteFile,
      oldPath: noteFile.path,
      renameMap: /* @__PURE__ */ new Map(),
      forceMarkdownLinks: true,
      embedOnlyLinks
    });
    return result;
  }
  async checkConsistency(note, badLinks, badEmbeds, wikiLinks, wikiEmbeds) {
    if (this.isPathIgnored(note.path)) {
      return;
    }
    const cache = await getCacheSafe(this.app, note.path);
    if (!cache) {
      return;
    }
    const links = cache.links ?? [];
    const embeds = cache.embeds ?? [];
    for (const link of links) {
      if (!await this.isValidLink(link, note.path)) {
        badLinks.add(note.path, link);
      }
      if (link.original.includes("[[")) {
        wikiLinks.add(note.path, link);
      }
    }
    for (const embed of embeds) {
      if (!await this.isValidLink(embed, note.path)) {
        badEmbeds.add(note.path, embed);
      }
      if (embed.original.includes("[[")) {
        wikiEmbeds.add(note.path, embed);
      }
    }
  }
  async updateLinks(note, oldNotePath, pathChangeMap, changeLinksAlt) {
    await applyFileChanges(this.app, note, async () => {
      const cache = await getCacheSafe(this.app, note);
      if (!cache) {
        return [];
      }
      const links = getAllLinks(cache);
      return links.map((link) => ({
        startIndex: link.position.start.offset,
        endIndex: link.position.end.offset,
        oldContent: link.original,
        newContent: this.convertLink({
          note,
          link,
          oldNotePath,
          pathChangeMap,
          changeLinksAlt
        })
      }));
    });
  }
};

// src/files-handler.ts
var import_obsidian5 = require("obsidian");
var import_path4 = __toESM(require_path(), 1);

// src/AttachmentPath.ts
var import_path3 = __toESM(require_path(), 1);
var import_implementations2 = __toESM(require_implementations(), 1);
var {
  basename: basename2,
  dirname: dirname2,
  extname: extname2
} = import_path3.posix;
async function getAttachmentFolderPath(app, notePath) {
  return dirname2(await getAttachmentFilePath(app, "DUMMY_FILE.pdf", notePath));
}
async function getAttachmentFilePath(app, attachmentPath, notePath) {
  const note = (0, import_implementations2.createTFileInstance)(app.vault, notePath);
  const ext = extname2(attachmentPath);
  const fileName = basename2(attachmentPath, ext);
  const originalMkdir = app.vault.adapter.mkdir;
  app.vault.adapter.mkdir = async (path) => {
    if (new Error().stack?.includes("getAvailablePathForAttachments")) {
      return;
    }
    return originalMkdir.call(app.vault.adapter, path);
  };
  try {
    const newAttachmentPath = await app.vault.getAvailablePathForAttachments(fileName, ext.slice(1), note);
    return newAttachmentPath;
  } finally {
    app.vault.adapter.mkdir = originalMkdir;
  }
}

// src/files-handler.ts
var {
  basename: basename3,
  dirname: dirname3,
  extname: extname3,
  join: join2
} = import_path4.posix;
var FilesHandler = class {
  constructor(app, lh, consoleLogPrefix = "", ignoreFolders = [], ignoreFilesRegex = [], shouldDeleteEmptyFolders = false) {
    this.app = app;
    this.lh = lh;
    this.consoleLogPrefix = consoleLogPrefix;
    this.ignoreFolders = ignoreFolders;
    this.ignoreFilesRegex = ignoreFilesRegex;
    this.shouldDeleteEmptyFolders = shouldDeleteEmptyFolders;
  }
  isPathIgnored(path) {
    if (path.startsWith("./")) {
      path = path.substring(2);
    }
    for (const folder of this.ignoreFolders) {
      if (path.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this.ignoreFilesRegex) {
      const testResult = fileRegex.test(path);
      if (testResult) {
        return true;
      }
    }
    return false;
  }
  async createFolderForAttachmentFromPath(filePath) {
    await createFolderSafe(this.app, dirname3(filePath));
  }
  generateFileCopyName(path) {
    const ext = extname3(path);
    const dir = dirname3(path);
    const fileName = basename3(path, ext);
    return this.app.vault.getAvailablePath(join2(dir, fileName), ext.slice(1));
  }
  async collectAttachmentsForCachedNote(notePath, deleteExistFiles, deleteEmptyFolders) {
    if (this.isPathIgnored(notePath)) {
      return { movedAttachments: [], renamedFiles: [] };
    }
    const result = {
      movedAttachments: [],
      renamedFiles: []
    };
    const cache = await getCacheSafe(this.app, notePath);
    if (!cache) {
      return result;
    }
    for (const link of getAllLinks(cache)) {
      const { linkPath } = splitSubpath(link.link);
      if (!linkPath) {
        continue;
      }
      const fullPathLink = this.lh.getFullPathForLink(linkPath, notePath);
      if (result.movedAttachments.findIndex((x) => x.oldPath == fullPathLink) != -1) {
        continue;
      }
      const file = this.lh.getFileByLink(linkPath, notePath);
      if (!file) {
        const type = link.original.startsWith("!") ? "embed" : "link";
        console.warn(`${this.consoleLogPrefix}${notePath} has bad ${type} (file does not exist): ${linkPath}`);
        continue;
      }
      if (!this.isAttachment(file)) {
        continue;
      }
      const newPath = await getAttachmentFilePath(this.app, file.path, notePath);
      if (dirname3(newPath) === dirname3(file.path)) {
        continue;
      }
      const res = await this.moveAttachment(file, newPath, [notePath], deleteExistFiles, deleteEmptyFolders);
      result.movedAttachments = result.movedAttachments.concat(res.movedAttachments);
      result.renamedFiles = result.renamedFiles.concat(res.renamedFiles);
    }
    return result;
  }
  async moveAttachment(file, newLinkPath, parentNotePaths, deleteExistFiles, deleteEmptyFolders) {
    const path = file.path;
    const result = {
      movedAttachments: [],
      renamedFiles: []
    };
    if (this.isPathIgnored(path)) {
      return result;
    }
    if (!this.isAttachment(file)) {
      return result;
    }
    if (path == newLinkPath) {
      console.warn(this.consoleLogPrefix + "Can't move file. Source and destination path the same.");
      return result;
    }
    await this.createFolderForAttachmentFromPath(newLinkPath);
    const linkedNotes = await this.lh.getCachedNotesThatHaveLinkToFile(path);
    if (parentNotePaths) {
      for (const notePath of parentNotePaths) {
        linkedNotes.remove(notePath);
      }
    }
    if (path !== file.path) {
      console.warn(this.consoleLogPrefix + "File was moved already");
      return await this.moveAttachment(file, newLinkPath, parentNotePaths, deleteExistFiles, deleteEmptyFolders);
    }
    const oldFolder = file.parent;
    if (linkedNotes.length == 0) {
      const existFile = this.app.vault.getFileByPath(newLinkPath);
      if (!existFile) {
        console.log(this.consoleLogPrefix + "move file [from, to]: \n   " + path + "\n   " + newLinkPath);
        result.movedAttachments.push({ oldPath: path, newPath: newLinkPath });
        await this.app.vault.rename(file, newLinkPath);
      } else {
        if (deleteExistFiles) {
          console.log(this.consoleLogPrefix + "delete file: \n   " + path);
          result.movedAttachments.push({ oldPath: path, newPath: newLinkPath });
          await this.deleteFile(file, deleteEmptyFolders);
        } else {
          const newFileCopyName = this.generateFileCopyName(newLinkPath);
          console.log(this.consoleLogPrefix + "copy file with new name [from, to]: \n   " + path + "\n   " + newFileCopyName);
          result.movedAttachments.push({ oldPath: path, newPath: newFileCopyName });
          await this.app.vault.rename(file, newFileCopyName);
          result.renamedFiles.push({ oldPath: newLinkPath, newPath: newFileCopyName });
        }
      }
    } else {
      const existFile = this.app.vault.getFileByPath(newLinkPath);
      if (!existFile) {
        console.log(this.consoleLogPrefix + "copy file [from, to]: \n   " + path + "\n   " + newLinkPath);
        result.movedAttachments.push({ oldPath: path, newPath: newLinkPath });
        await this.app.vault.rename(file, newLinkPath);
        await this.app.vault.copy(file, path);
      } else {
        if (deleteExistFiles) {
        } else {
          const newFileCopyName = this.generateFileCopyName(newLinkPath);
          console.log(this.consoleLogPrefix + "copy file with new name [from, to]: \n   " + path + "\n   " + newFileCopyName);
          result.movedAttachments.push({ oldPath: file.path, newPath: newFileCopyName });
          await this.app.vault.rename(file, newFileCopyName);
          await this.app.vault.copy(file, path);
          result.renamedFiles.push({ oldPath: newLinkPath, newPath: newFileCopyName });
        }
      }
    }
    if (this.shouldDeleteEmptyFolders) {
      await removeEmptyFolderHierarchy(this.app, oldFolder);
    }
    return result;
  }
  async deleteEmptyFolders(dirName) {
    if (this.isPathIgnored(dirName)) {
      return;
    }
    if (dirName.startsWith("./")) {
      dirName = dirName.substring(2);
    }
    let list = await safeList(this.app, dirName);
    for (const folder of list.folders) {
      await this.deleteEmptyFolders(folder);
    }
    list = await safeList(this.app, dirName);
    if (list.files.length == 0 && list.folders.length == 0) {
      console.log(this.consoleLogPrefix + "delete empty folder: \n   " + dirName);
      if (await this.app.vault.adapter.exists(dirName)) {
        try {
          await this.app.vault.adapter.rmdir(dirName, false);
        } catch (e) {
          if (await this.app.vault.adapter.exists(dirName)) {
            throw e;
          }
        }
      }
    }
  }
  async deleteFile(file, deleteEmptyFolders) {
    await this.app.vault.trash(file, true);
    if (deleteEmptyFolders) {
      let dir = file.parent;
      while (dir.children.length === 0) {
        await this.app.vault.trash(dir, true);
        dir = dir.parent;
      }
    }
  }
  isAttachment(file) {
    const extension = file.extension.toLowerCase();
    return extension !== "md" && extension !== "canvas";
  }
};

// src/ConsistentAttachmentsAndLinksPluginSettingsTab.ts
var import_obsidian6 = require("obsidian");
var ConsistentAttachmentsAndLinksPluginSettingsTab = class extends import_obsidian6.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Consistent attachments and links - Settings" });
    const settings = this.plugin.settings;
    new import_obsidian6.Setting(containerEl).setName("Move Attachments with Note").setDesc("Automatically move attachments when a note is relocated. This includes attachments located in the same folder or any of its subfolders.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.moveAttachmentsWithNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.moveAttachmentsWithNote));
    new import_obsidian6.Setting(containerEl).setName("Delete Unused Attachments with Note").setDesc("Automatically remove attachments that are no longer referenced in other notes when the note is deleted.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteAttachmentsWithNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteAttachmentsWithNote));
    new import_obsidian6.Setting(containerEl).setName("Update Links").setDesc("Automatically update links to attachments and other notes when moving notes or attachments.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.updateLinks = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.updateLinks));
    new import_obsidian6.Setting(containerEl).setName("Delete Empty Folders").setDesc("Automatically remove empty folders after moving notes with attachments.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteEmptyFolders = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteEmptyFolders));
    new import_obsidian6.Setting(containerEl).setName("Delete Duplicate Attachments on Note Move").setDesc("Automatically delete attachments when moving a note if a file with the same name exists in the destination folder. If disabled, the file will be renamed and moved.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.deleteExistFilesWhenMoveNote = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.deleteExistFilesWhenMoveNote));
    new import_obsidian6.Setting(containerEl).setName("Update Backlink Text on Note Rename").setDesc("When a note is renamed, its linked references are automatically updated. If this option is enabled, the text of backlinks to this note will also be modified.").addToggle((cb) => cb.onChange(
      async (value) => {
        settings.changeNoteBacklinksAlt = value;
        await this.plugin.saveSettings(settings);
      }
    ).setValue(settings.changeNoteBacklinksAlt));
    new import_obsidian6.Setting(containerEl).setName("Ignore Folders").setDesc("Specify a list of folders to ignore. Enter each folder on a new line.").addTextArea((cb) => cb.setPlaceholder("Example: .git, .obsidian").setValue(settings.ignoreFolders.join("\n")).onChange(async (value) => {
      const paths = value.trim().split("\n").map((value2) => this.getNormalizedPath(value2) + "/");
      settings.ignoreFolders = paths;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian6.Setting(containerEl).setName("Ignore Files").setDesc("Specify a list of files to ignore. Enter each file on a new line.").addTextArea((cb) => cb.setPlaceholder("Example: consistent-report.md").setValue(settings.ignoreFiles.join("\n")).onChange(async (value) => {
      const paths = value.trim().split("\n");
      settings.ignoreFiles = paths;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian6.Setting(containerEl).setName("Consistency Report Filename").setDesc("Specify the name of the file for the consistency report.").addText((cb) => cb.setPlaceholder("Example: consistency-report.md").setValue(settings.consistencyReportFile).onChange(async (value) => {
      settings.consistencyReportFile = value;
      await this.plugin.saveSettings(settings);
    }));
    new import_obsidian6.Setting(containerEl).setName("Auto Collect Attachments").setDesc("Automatically collect attachments when the note is edited.").addToggle((toggle) => toggle.setValue(settings.autoCollectAttachments).onChange(async (value) => {
      settings.autoCollectAttachments = value;
      await this.plugin.saveSettings(settings);
    }));
  }
  getNormalizedPath(path) {
    return path.length == 0 ? path : (0, import_obsidian6.normalizePath)(path);
  }
};

// src/ConsistentAttachmentsAndLinksPluginSettings.ts
var ConsistentAttachmentsAndLinksPluginSettings = class _ConsistentAttachmentsAndLinksPluginSettings {
  autoCollectAttachments = false;
  changeNoteBacklinksAlt = false;
  consistencyReportFile = "consistency-report.md";
  deleteAttachmentsWithNote = true;
  deleteEmptyFolders = true;
  deleteExistFilesWhenMoveNote = true;
  ignoreFiles = ["consistency\\-report\\.md"];
  ignoreFolders = [".git/", ".obsidian/"];
  moveAttachmentsWithNote = true;
  showWarning = true;
  updateLinks = true;
  getIgnoreFilesRegex() {
    return this.ignoreFiles.map((file) => RegExp(file));
  }
  static load(data) {
    return _ConsistentAttachmentsAndLinksPluginSettings.clone(data);
  }
  static clone(settings) {
    const target = new _ConsistentAttachmentsAndLinksPluginSettings();
    if (settings) {
      for (const key of Object.keys(target)) {
        if (key in settings && typeof settings[key] === typeof target[key]) {
          Object.assign(target, { [key]: settings[key] });
        }
      }
    }
    return target;
  }
};

// src/RenameDeleteHandler.ts
var import_obsidian7 = require("obsidian");
var import_path5 = __toESM(require_path(), 1);
var {
  relative,
  join: join3,
  dirname: dirname4
} = import_path5.posix;
var renamingPaths = /* @__PURE__ */ new Set();
async function handleRename(plugin, file, oldPath) {
  if (renamingPaths.has(oldPath)) {
    return;
  }
  console.debug("Handle Rename");
  if (!(file instanceof import_obsidian7.TFile)) {
    return;
  }
  const app = plugin.app;
  const updateAllLinks = app.fileManager.updateAllLinks;
  try {
    plugin.app.fileManager.updateAllLinks = async () => {
    };
    const renameMap = /* @__PURE__ */ new Map();
    await fillRenameMap(app, file, oldPath, renameMap);
    for (const [oldPath2, newPath2] of renameMap.entries()) {
      await processRename(plugin, oldPath2, newPath2, renameMap);
    }
  } finally {
    renamingPaths.delete(oldPath);
    plugin.app.fileManager.updateAllLinks = updateAllLinks;
  }
}
async function handleDelete(plugin, file) {
  console.debug("Handle Delete");
  if (!isNote(file)) {
    return;
  }
  if (renamingPaths.has(file.path)) {
    return;
  }
  const attachmentFolder = await getAttachmentFolderPath(plugin.app, file.path);
  await removeFolderSafe(plugin.app, attachmentFolder, file.path);
}
async function fillRenameMap(app, file, oldPath, renameMap) {
  renameMap.set(oldPath, file.path);
  if (!isNote(file)) {
    return;
  }
  const oldAttachmentFolderPath = await getAttachmentFolderPath(app, oldPath);
  const newAttachmentFolderPath = await getAttachmentFolderPath(app, file.path);
  const dummyOldAttachmentFolderPath = await getAttachmentFolderPath(app, join3(dirname4(oldPath), "DUMMY_FILE.md"));
  const oldAttachmentFolder = app.vault.getFolderByPath(oldAttachmentFolderPath);
  if (!oldAttachmentFolder) {
    return;
  }
  if (oldAttachmentFolderPath === newAttachmentFolderPath) {
    return;
  }
  const children = [];
  if (oldAttachmentFolderPath === dummyOldAttachmentFolderPath) {
    const cache = await getCacheSafe(app, file);
    if (!cache) {
      return;
    }
    for (const link of getAllLinks(cache)) {
      const attachmentFile = extractLinkFile(app, link, oldPath);
      if (!attachmentFile) {
        continue;
      }
      if (attachmentFile.path.startsWith(oldAttachmentFolderPath)) {
        const backlinks = await getBacklinksForFileSafe(app, attachmentFile);
        if (backlinks.keys().length === 1) {
          children.push(attachmentFile);
        }
      }
    }
  } else {
    import_obsidian7.Vault.recurseChildren(oldAttachmentFolder, (child) => {
      if (child instanceof import_obsidian7.TFile) {
        children.push(child);
      }
    });
  }
  for (let child of children) {
    if (isNote(child)) {
      continue;
    }
    child = child;
    const relativePath = relative(oldAttachmentFolderPath, child.path);
    const newDir = join3(newAttachmentFolderPath, dirname4(relativePath));
    let newChildPath = join3(newDir, child.name);
    if (child.path !== newChildPath) {
      newChildPath = app.vault.getAvailablePath(join3(newDir, child.basename), child.extension);
      renameMap.set(child.path, newChildPath);
    }
  }
}
async function processRename(plugin, oldPath, newPath, renameMap) {
  const app = plugin.app;
  let oldFile = null;
  let fakeOldFileCreated = false;
  try {
    oldFile = app.vault.getFileByPath(oldPath);
    const newFile = app.vault.getFileByPath(newPath);
    const file = oldFile ?? newFile;
    if (!file) {
      return;
    }
    if (!oldFile) {
      fakeOldFileCreated = true;
      oldFile = await app.vault.create(oldPath, "");
    }
    const backlinks = await getBacklinks(plugin.app, oldFile, newFile);
    for (const parentNotePath of backlinks.keys()) {
      let parentNote = app.vault.getFileByPath(parentNotePath);
      if (!parentNote) {
        const newParentNotePath = renameMap.get(parentNotePath);
        if (newParentNotePath) {
          parentNote = app.vault.getFileByPath(newParentNotePath);
        }
      }
      if (!parentNote) {
        console.warn(`Parent note not found: ${parentNotePath}`);
        continue;
      }
      await applyFileChanges(app, parentNote, async () => {
        const links = (await getBacklinks(plugin.app, oldFile, newFile)).get(parentNotePath) ?? [];
        const changes = [];
        for (const link of links) {
          changes.push({
            startIndex: link.position.start.offset,
            endIndex: link.position.end.offset,
            oldContent: link.original,
            newContent: updateLink({
              app,
              link,
              file,
              oldPath,
              source: parentNote,
              renameMap
            })
          });
        }
        return changes;
      });
    }
    if (file.extension.toLowerCase() === "canvas") {
      await processWithRetry(app, file, (content) => {
        const canvasData = JSON.parse(content);
        for (const node of canvasData.nodes) {
          if (node.type !== "file") {
            continue;
          }
          const newPath2 = renameMap.get(node.file);
          if (!newPath2) {
            continue;
          }
          node.file = newPath2;
        }
        return toJson(canvasData);
      });
    } else if (file.extension.toLowerCase() === "md") {
      await updateLinksInFile({
        app,
        file,
        oldPath,
        renameMap
      });
    }
    if (!fakeOldFileCreated) {
      await createFolderSafe(app, dirname4(newPath));
      const oldFolder = oldFile.parent;
      if (newFile) {
        await app.vault.delete(newFile);
      }
      await app.vault.rename(oldFile, newPath);
      if (plugin.settings.deleteEmptyFolders) {
        await removeEmptyFolderHierarchy(app, oldFolder);
      }
    }
  } finally {
    if (fakeOldFileCreated && oldFile) {
      await app.vault.delete(oldFile);
    }
    renameMap.delete(oldPath);
  }
}
async function getBacklinks(app, oldFile, newFile) {
  const backlinks = /* @__PURE__ */ new Map();
  const oldLinks = await getBacklinksForFileSafe(app, oldFile);
  for (const path of oldLinks.keys()) {
    backlinks.set(path, oldLinks.get(path));
  }
  if (!newFile) {
    return backlinks;
  }
  const newLinks = await getBacklinksForFileSafe(app, newFile);
  for (const path of newLinks.keys()) {
    const links = backlinks.get(path) ?? [];
    links.push(...newLinks.get(path));
    backlinks.set(path, links);
  }
  return backlinks;
}

// src/ConsistentAttachmentsAndLinksPlugin.ts
var import_path6 = __toESM(require_path(), 1);
var { dirname: dirname5 } = import_path6.posix;
var ConsistentAttachmentsAndLinksPlugin = class extends import_obsidian8.Plugin {
  _settings;
  lh;
  fh;
  isHandlingMetadataCacheChanged = false;
  abortSignal;
  deletedNoteCache = /* @__PURE__ */ new Map();
  get settings() {
    return ConsistentAttachmentsAndLinksPluginSettings.clone(this._settings);
  }
  async onload() {
    await this.loadSettings();
    if (this._settings.showWarning) {
      const notice = new import_obsidian8.Notice(createFragment((f) => {
        f.appendText("Starting from ");
        appendCodeBlock(f, "v3.0.0");
        f.appendText(", the plugin ");
        appendCodeBlock(f, "Consistent Attachments and Links");
        f.appendText(" has setting ");
        appendCodeBlock(f, "Attachment Subfolder");
        f.appendText(" removed. This is a BREAKING CHANGE.");
        f.appendChild(createEl("br"));
        f.appendChild(createEl("a", { text: "Read more", href: "https://github.com/dy-sh/obsidian-consistent-attachments-and-links?tab=readme-ov-file#attachment-subfolder-setting" }));
      }), 0);
      notice.noticeEl.onClickEvent(convertAsyncToSync(async (ev) => {
        if (ev.target instanceof HTMLAnchorElement) {
          ev.preventDefault();
          window.open(ev.target.href, "_blank");
        } else {
          this._settings.showWarning = false;
          await this.saveSettings(this._settings);
        }
      }));
    }
    this.addSettingTab(new ConsistentAttachmentsAndLinksPluginSettingsTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("deleted", (file, prevCache) => this.handleDeletedMetadata(file, prevCache))
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => convertToSync(handleDelete(this, file)))
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => convertToSync(handleRename(this, file, oldPath)))
    );
    this.addCommand({
      id: "collect-all-attachments",
      name: "Collect All Attachments",
      callback: () => this.collectAllAttachments()
    });
    this.addCommand({
      id: "collect-attachments-current-note",
      name: "Collect Attachments in Current Note",
      checkCallback: this.collectAttachmentsCurrentNote.bind(this)
    });
    this.addCommand({
      id: "delete-empty-folders",
      name: "Delete Empty Folders",
      callback: () => this.deleteEmptyFolders()
    });
    this.addCommand({
      id: "convert-all-link-paths-to-relative",
      name: "Convert All Link Paths to Relative",
      callback: () => this.convertAllLinkPathsToRelative()
    });
    this.addCommand({
      id: "convert-all-link-paths-to-relative-current-note",
      name: "Convert All Link Paths to Relative in Current Note",
      checkCallback: this.convertAllLinkPathsToRelativeCurrentNote.bind(this)
    });
    this.addCommand({
      id: "convert-all-embed-paths-to-relative",
      name: "Convert All Embed Paths to Relative",
      callback: () => this.convertAllEmbedsPathsToRelative()
    });
    this.addCommand({
      id: "convert-all-embed-paths-to-relative-current-note",
      name: "Convert All Embed Paths to Relative in Current Note",
      checkCallback: this.convertAllEmbedsPathsToRelativeCurrentNote.bind(this)
    });
    this.addCommand({
      id: "replace-all-wikilinks-with-markdown-links",
      name: "Replace All Wiki Links with Markdown Links",
      callback: () => this.replaceAllWikilinksWithMarkdownLinks()
    });
    this.addCommand({
      id: "replace-all-wikilinks-with-markdown-links-current-note",
      name: "Replace All Wiki Links with Markdown Links in Current Note",
      checkCallback: this.replaceAllWikilinksWithMarkdownLinksCurrentNote.bind(this)
    });
    this.addCommand({
      id: "replace-all-wiki-embeds-with-markdown-embeds",
      name: "Replace All Wiki Embeds with Markdown Embeds",
      callback: () => this.replaceAllWikiEmbedsWithMarkdownEmbeds()
    });
    this.addCommand({
      id: "replace-all-wiki-embeds-with-markdown-embeds-current-note",
      name: "Replace All Wiki Embeds with Markdown Embeds in Current Note",
      checkCallback: this.replaceAllWikiEmbedsWithMarkdownEmbedsCurrentNote.bind(this)
    });
    this.addCommand({
      id: "reorganize-vault",
      name: "Reorganize Vault",
      callback: () => this.reorganizeVault()
    });
    this.addCommand({
      id: "check-consistency",
      name: "Check Vault consistency",
      callback: () => this.checkConsistency()
    });
    this.registerEvent(this.app.metadataCache.on("changed", (file) => convertToSync(this.handleMetadataCacheChanged(file))));
    this.lh = new LinksHandler(
      this.app,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
    this.fh = new FilesHandler(
      this.app,
      this.lh,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex(),
      this._settings.deleteEmptyFolders
    );
    const abortController = new AbortController();
    this.register(() => abortController.abort());
    this.abortSignal = abortController.signal;
  }
  isPathIgnored(path) {
    if (path.startsWith("./")) {
      path = path.substring(2);
    }
    for (const folder of this._settings.ignoreFolders) {
      if (path.startsWith(folder)) {
        return true;
      }
    }
    for (const fileRegex of this._settings.getIgnoreFilesRegex()) {
      if (fileRegex.test(path)) {
        return true;
      }
    }
    return false;
  }
  handleDeletedMetadata(file, prevCache) {
    if (!prevCache || !this._settings.deleteAttachmentsWithNote || this.isPathIgnored(file.path) || file.extension.toLowerCase() !== "md") {
      return;
    }
    this.deletedNoteCache.set(file.path, prevCache);
  }
  collectAttachmentsCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.collectAttachments(note));
    }
    return true;
  }
  async collectAttachments(note, isVerbose = true) {
    if (this.isPathIgnored(note.path)) {
      new import_obsidian8.Notice("Note path is ignored");
      return;
    }
    await this.saveAllOpenNotes();
    const result = await this.fh.collectAttachmentsForCachedNote(
      note.path,
      this._settings.deleteExistFilesWhenMoveNote,
      this._settings.deleteEmptyFolders
    );
    if (result && result.movedAttachments && result.movedAttachments.length > 0) {
      await this.lh.updateChangedPathsInNote(note.path, result.movedAttachments);
    }
    if (result.movedAttachments.length == 0) {
      if (isVerbose) {
        new import_obsidian8.Notice("No files found that need to be moved");
      }
    } else {
      new import_obsidian8.Notice("Moved " + result.movedAttachments.length + " attachment" + (result.movedAttachments.length > 1 ? "s" : ""));
    }
  }
  async collectAllAttachments() {
    let movedAttachmentsCount = 0;
    let processedNotesCount = 0;
    await this.saveAllOpenNotes();
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Collecting attachments # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.fh.collectAttachmentsForCachedNote(
        note.path,
        this._settings.deleteExistFilesWhenMoveNote,
        this._settings.deleteEmptyFolders
      );
      if (result && result.movedAttachments && result.movedAttachments.length > 0) {
        await this.lh.updateChangedPathsInNote(note.path, result.movedAttachments);
        movedAttachmentsCount += result.movedAttachments.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (movedAttachmentsCount == 0) {
      new import_obsidian8.Notice("No files found that need to be moved");
    } else {
      new import_obsidian8.Notice("Moved " + movedAttachmentsCount + " attachment" + (movedAttachmentsCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async convertAllEmbedsPathsToRelative() {
    await this.saveAllOpenNotes();
    let changedEmbedCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Converting embed paths to relative # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.convertAllNoteEmbedsPathsToRelative(note.path);
      if (result && result.length > 0) {
        changedEmbedCount += result.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (changedEmbedCount == 0) {
      new import_obsidian8.Notice("No embeds found that need to be converted");
    } else {
      new import_obsidian8.Notice("Converted " + changedEmbedCount + " embed" + (changedEmbedCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async convertAllLinkPathsToRelative() {
    await this.saveAllOpenNotes();
    let changedLinksCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Converting link paths to relative # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.convertAllNoteLinksPathsToRelative(note.path);
      if (result && result.length > 0) {
        changedLinksCount += result.length;
        processedNotesCount++;
      }
    }
    notice.hide();
    if (changedLinksCount == 0) {
      new import_obsidian8.Notice("No links found that need to be converted");
    } else {
      new import_obsidian8.Notice("Converted " + changedLinksCount + " link" + (changedLinksCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async replaceAllWikilinksWithMarkdownLinks() {
    await this.saveAllOpenNotes();
    let changedLinksCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Replacing wikilinks with markdown links # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.replaceAllNoteWikilinksWithMarkdownLinks(note.path, false);
      changedLinksCount += result;
      processedNotesCount++;
    }
    notice.hide();
    if (changedLinksCount == 0) {
      new import_obsidian8.Notice("No wiki links found that need to be replaced");
    } else {
      new import_obsidian8.Notice("Replaced " + changedLinksCount + " wikilink" + (changedLinksCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async replaceAllWikiEmbedsWithMarkdownEmbeds() {
    await this.saveAllOpenNotes();
    let changedLinksCount = 0;
    let processedNotesCount = 0;
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Replacing wiki embeds with markdown embeds # ${i} / ${notes.length} - ${note.path}`;
      notice.setMessage(message);
      console.debug(message);
      if (this.isPathIgnored(note.path)) {
        continue;
      }
      const result = await this.lh.replaceAllNoteWikilinksWithMarkdownLinks(note.path, true);
      changedLinksCount += result;
      processedNotesCount++;
    }
    notice.hide();
    if (changedLinksCount == 0) {
      new import_obsidian8.Notice("No wiki embeds found that need to be replaced");
    } else {
      new import_obsidian8.Notice("Replaced " + changedLinksCount + " wiki embed" + (changedLinksCount > 1 ? "s" : "") + " from " + processedNotesCount + " note" + (processedNotesCount > 1 ? "s" : ""));
    }
  }
  async deleteEmptyFolders() {
    await this.fh.deleteEmptyFolders("/");
  }
  async checkConsistency() {
    await this.saveAllOpenNotes();
    const badLinks = new ConsistencyCheckResult("Bad links");
    const badEmbeds = new ConsistencyCheckResult("Bad embeds");
    const wikiLinks = new ConsistencyCheckResult("Wiki links");
    const wikiEmbeds = new ConsistencyCheckResult("Wiki embeds");
    const notes = getMarkdownFilesSorted(this.app);
    let i = 0;
    const notice = new import_obsidian8.Notice("", 0);
    for (const note2 of notes) {
      if (this.abortSignal.aborted) {
        notice.hide();
        return;
      }
      i++;
      const message = `Checking note # ${i} / ${notes.length} - ${note2.path}`;
      notice.setMessage(message);
      console.debug(message);
      await this.lh.checkConsistency(note2, badLinks, badEmbeds, wikiLinks, wikiEmbeds);
    }
    notice.hide();
    const notePath = this._settings.consistencyReportFile;
    const text = badLinks.toString(this.app, notePath) + badEmbeds.toString(this.app, notePath) + wikiLinks.toString(this.app, notePath) + wikiEmbeds.toString(this.app, notePath);
    await createFolderSafe(this.app, dirname5(notePath));
    const note = this.app.vault.getFileByPath(notePath) ?? await this.app.vault.create(notePath, "");
    await this.app.vault.modify(note, text);
    let fileOpened = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.getDisplayText() != "" && notePath.startsWith(leaf.getDisplayText())) {
        fileOpened = true;
      }
    });
    if (!fileOpened) {
      await this.app.workspace.openLinkText(notePath, "/", false);
    }
  }
  async reorganizeVault() {
    await this.saveAllOpenNotes();
    await this.replaceAllWikilinksWithMarkdownLinks();
    await this.replaceAllWikiEmbedsWithMarkdownEmbeds();
    await this.convertAllEmbedsPathsToRelative();
    await this.convertAllLinkPathsToRelative();
    await this.collectAllAttachments();
    await this.deleteEmptyFolders();
    new import_obsidian8.Notice("Reorganization of the vault completed");
  }
  async loadSettings() {
    this._settings = ConsistentAttachmentsAndLinksPluginSettings.load(await this.loadData());
  }
  async saveSettings(newSettings) {
    this._settings = ConsistentAttachmentsAndLinksPluginSettings.clone(newSettings);
    await this.saveData(this._settings);
    this.lh = new LinksHandler(
      this.app,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
    this.fh = new FilesHandler(
      this.app,
      this.lh,
      "Consistent Attachments and Links: ",
      this._settings.ignoreFolders,
      this._settings.getIgnoreFilesRegex()
    );
  }
  async saveAllOpenNotes() {
    for (const leaf of this.app.workspace.getLeavesOfType("markdown")) {
      const view = leaf.view;
      await view.save();
    }
  }
  convertAllLinkPathsToRelativeCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.lh.convertAllNoteLinksPathsToRelative(note.path));
    }
    return true;
  }
  convertAllEmbedsPathsToRelativeCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.lh.convertAllNoteEmbedsPathsToRelative(note.path));
    }
    return true;
  }
  replaceAllWikilinksWithMarkdownLinksCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.lh.replaceAllNoteWikilinksWithMarkdownLinks(note.path, false));
    }
    return true;
  }
  replaceAllWikiEmbedsWithMarkdownEmbedsCurrentNote(checking) {
    const note = this.app.workspace.getActiveFile();
    if (!note || note.extension.toLowerCase() !== "md") {
      return false;
    }
    if (!checking) {
      convertToSync(this.lh.replaceAllNoteWikilinksWithMarkdownLinks(note.path, true));
    }
    return true;
  }
  async handleMetadataCacheChanged(file) {
    if (!this._settings.autoCollectAttachments) {
      return;
    }
    const suggestionContainer = document.querySelector(".suggestion-container");
    if (suggestionContainer && suggestionContainer.style.display !== "none") {
      return;
    }
    if (this.isHandlingMetadataCacheChanged) {
      return;
    }
    this.isHandlingMetadataCacheChanged = true;
    try {
      await this.collectAttachments(file, false);
    } finally {
      this.isHandlingMetadataCacheChanged = false;
    }
  }
};
function appendCodeBlock(fragment, text) {
  fragment.appendChild(createSpan({ cls: "markdown-rendered code" }, (span) => {
    span.style.fontWeight = "bold";
    span.appendChild(createEl("code", { text }));
  }));
}
